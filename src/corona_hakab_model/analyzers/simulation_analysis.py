from typing import List, Callable, Dict
import os
from glob import glob
from project_structure import OUTPUT_FOLDER
import pandas as pd
from datetime import datetime
from itertools import chain

import numpy as np
import matplotlib.pyplot as plt


def create_comparison_files(files: list = None):
    """

    :param files: Files to compare. If not given, takes all the files in the output folder.
    :return: N/A. For each parameter creates a file combining the information from each file.
    """
    if files is None:
        files = glob(os.path.join(OUTPUT_FOLDER, "*.csv"))
    dfs_dict = dict(map(lambda f: (os.path.basename(f),
                                   pd.read_csv(f).drop(["Unnamed: 0"], axis=1, errors='ignore')),
                        files))
    dfs_columns = map(lambda f: f.columns.tolist(), dfs_dict.values())
    parameters_to_compare = set(chain.from_iterable(dfs_columns))
    result_folder_name = os.path.join(OUTPUT_FOLDER, datetime.now().strftime("%Y_%m_%d-%H_%M_%S"))
    os.mkdir(result_folder_name)
    for parameter in parameters_to_compare:
        result_df = pd.DataFrame(columns=dfs_dict.keys())
        for file_name, file_df in dfs_dict.items():
            if parameter in file_df.columns:
                result_df.loc[:, file_name] = file_df.loc[:, parameter]
            else:
                result_df.loc[:, file_name] = pd.nan
        result_df.to_csv(os.path.join(result_folder_name, f"{parameter}.csv"))


def plot_minmax_barchart_single_param(param_csvfile_path):
    """

    :param param_csvfile_path: a path to csv file to aggregate the data from assumes generated by create_comparison_files
    :return: return None and plot a matplotlib bar-chart
    """
    plot_aggregations_from_csv(param_csvfile_path, {"min": np.min, "max": np.max})


def plot_aggregations_from_csv(csv_file_path, aggregation_funcs: Dict[str, Callable]):
    """

    :param csv_file_path: a path to csv file to aggregate the data from assumes generated by create_comparison_files
    :param aggregation_funcs: all the aggregation functions that want to be apllied per columns
    :return: return None and plot a matplotlib bar-chart
    """
    source_df = pd.read_csv(csv_file_path).drop(["Unnamed: 0"], axis=1, errors='ignore')
    agg_df = source_df.agg(list(aggregation_funcs.values()))

    n_aggregations = len(aggregation_funcs)
    n_runs = source_df.shape[1]

    runs_labels = list(agg_df.columns)
    x = np.arange(n_runs)  # the label locations
    width = 1/(n_aggregations+1)  # the width of the bars

    fig, ax = plt.subplots()
    rects = []
    for i, (agg_name, (_, agg_values)) in enumerate(zip(aggregation_funcs.keys(), agg_df.iterrows())):
        rects.append(ax.bar(x - width * (- n_aggregations + 2 * i) / 2, list(agg_values), width, label=agg_name))

    ax.set_title(f"aggregation of {csv_file_path.split('/')[-1]}")
    ax.set_xticks(x)
    ax.set_xticklabels(runs_labels)
    ax.legend()

    def label_rects_with_hight(rects):
        """Attach a text label above each bar in *rects*, displaying its height."""
        for rect in rects:
            height = rect.get_height()
            ax.annotate('{}'.format(height),
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom')

    for rect in rects:
        label_rects_with_hight(rect)

    fig.tight_layout()
    plt.show()

