# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


	# flake8: noqa
from sparse_base import SparseBase, ManifestBase

import numpy as np
size_t = np.dtype('uint64')



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _sparse
else:
    import _sparse
from consts import generator

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class MagicOperator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def operate(self, w_val: "dtype", v_val: "dtype") -> "dtype":
        return _sparse.MagicOperator_operate(self, w_val, v_val)

    def mul(self, factor: "dtype") -> "MagicOperator *":
        return _sparse.MagicOperator_mul(self, factor)

    def __init__(self):
        _sparse.MagicOperator_swiginit(self, _sparse.new_MagicOperator())
    __swig_destroy__ = _sparse.delete_MagicOperator

# Register MagicOperator in _sparse:
_sparse.MagicOperator_swigregister(MagicOperator)

class ManifestMatrix(ManifestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get(self, row: "size_t", column: "size_t") -> "dtype":
        r"""
        get(self, row, column) -> dtype

        Parameters
        ----------
        row: size_t
        column: size_t

        """
        return _sparse.ManifestMatrix_get(self, row, column)

    def I_POA(self, A_values: "dtype const *", A_nz_indices: "size_t const *", op: "MagicOperator") -> "void":
        r"""
        I_POA(self, A_values, A_nz_indices, op)

        Parameters
        ----------
        A_values: dtype const *
        A_nz_indices: size_t const *
        op: MagicOperator *const &

        """
        return _sparse.ManifestMatrix_I_POA(self, A_values, A_nz_indices, op)

    def nz_rows(self) -> "std::vector< std::vector< size_t > >":
        r"""nz_rows(self) -> std::vector< std::vector< size_t > >"""
        return _sparse.ManifestMatrix_nz_rows(self)
    __swig_destroy__ = _sparse.delete_ManifestMatrix

    if '''I_POA''' not in locals():

    	def I_POA(self, v, op): pass


    if '''__getitem__''' not in locals():

    	def __getitem__(self,item): pass


# Register ManifestMatrix in _sparse:
_sparse.ManifestMatrix_swigregister(ManifestMatrix)


__temp_store = getattr(ManifestMatrix,"""I_POA""",None)
def __temp_def(self, v, op):
	nz = np.flatnonzero(v).astype(np.uint64, copy=False)
	return self.I_POA.prev(self, v, nz, op)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
ManifestMatrix.I_POA = __temp_def
del __temp_store, __temp_def


__temp_store = getattr(ManifestMatrix,"""__getitem__""",None)
def __temp_def(self,item):
	i, j = item
	return self.get(i, j)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
ManifestMatrix.__getitem__ = __temp_def
del __temp_store, __temp_def

class SparseMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = property(_sparse.SparseMatrix_size_get)

    def __init__(self, size: "size_t"):
        r"""
        __init__(self, size) -> SparseMatrix

        Parameters
        ----------
        size: size_t

        """
        _sparse.SparseMatrix_swiginit(self, _sparse.new_SparseMatrix(size))

    def batch_set(self, row: "size_t", A_columns: "size_t const *", A_probs: "dtype const *", A_values: "dtype const *") -> "void":
        r"""
        batch_set(self, row, A_columns, A_probs, A_values)

        Parameters
        ----------
        row: size_t
        A_columns: size_t const *
        A_probs: dtype const *
        A_values: dtype const *

        """
        return _sparse.SparseMatrix_batch_set(self, row, A_columns, A_probs, A_values)

    def has_value(self, row: "size_t", column: "size_t") -> "bool":
        return _sparse.SparseMatrix_has_value(self, row, column)

    def get(self, row: "size_t", column: "size_t") -> "std::tuple< dtype,dtype >":
        return _sparse.SparseMatrix_get(self, row, column)

    def nz_count(self) -> "size_t":
        r"""nz_count(self) -> size_t"""
        return _sparse.SparseMatrix_nz_count(self)

    def manifest(self, A_rolls: "dtype const *") -> "ManifestMatrix *":
        r"""
        manifest(self, A_rolls) -> ManifestMatrix

        Parameters
        ----------
        A_rolls: dtype const *

        """
        return _sparse.SparseMatrix_manifest(self, A_rolls)

    def row_set_prob_coff(self, row: "size_t", coff: "dtype") -> "void":
        r"""
        row_set_prob_coff(self, row, coff)

        Parameters
        ----------
        row: size_t
        coff: dtype

        """
        return _sparse.SparseMatrix_row_set_prob_coff(self, row, coff)

    def col_set_prob_coff(self, column: "size_t", coff: "dtype") -> "void":
        r"""
        col_set_prob_coff(self, column, coff)

        Parameters
        ----------
        column: size_t
        coff: dtype

        """
        return _sparse.SparseMatrix_col_set_prob_coff(self, column, coff)

    def row_set_value_offset(self, row: "size_t", offset: "dtype") -> "void":
        r"""
        row_set_value_offset(self, row, offset)

        Parameters
        ----------
        row: size_t
        offset: dtype

        """
        return _sparse.SparseMatrix_row_set_value_offset(self, row, offset)

    def col_set_value_offset(self, column: "size_t", offset: "dtype") -> "void":
        r"""
        col_set_value_offset(self, column, offset)

        Parameters
        ----------
        column: size_t
        offset: dtype

        """
        return _sparse.SparseMatrix_col_set_value_offset(self, column, offset)

    def non_zero_columns(self) -> "std::vector< std::vector< size_t > >":
        r"""non_zero_columns(self) -> std::vector< std::vector< size_t > >"""
        return _sparse.SparseMatrix_non_zero_columns(self)
    __swig_destroy__ = _sparse.delete_SparseMatrix

    if '''__getitem__''' not in locals():

    	def __getitem__(self,item): pass


    if '''manifest''' not in locals():

    	def manifest(self, sample=None, global_prob_factor=1): pass


    if '''batch_set''' not in locals():

    	def batch_set(self,row,columns,probs,values): pass


# Register SparseMatrix in _sparse:
_sparse.SparseMatrix_swigregister(SparseMatrix)


__temp_store = getattr(SparseMatrix,"""__getitem__""",None)
def __temp_def(self,item):
	i, j = item
	if not self.has_value(i, j):
	    return None
	return self.get(i, j)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
SparseMatrix.__getitem__ = __temp_def
del __temp_store, __temp_def


__temp_store = getattr(SparseMatrix,"""manifest""",None)
def __temp_def(self, sample=None, global_prob_factor=1):
	if sample is None:
	    sample = generator.random(self.nz_count(), dtype=np.float32)
	if global_prob_factor != 1:
	    sample /= global_prob_factor
	return self.manifest.prev(self, sample)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
SparseMatrix.manifest = __temp_def
del __temp_store, __temp_def


__temp_store = getattr(SparseMatrix,"""batch_set""",None)
def __temp_def(self,row,columns,probs,values):
	columns = np.asanyarray(columns, dtype=size_t)
	probs = np.asanyarray(probs, dtype=np.float32)
	values = np.asanyarray(values, dtype=np.float32)
	return self.batch_set.prev(self, row,columns,probs,values)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
SparseMatrix.batch_set = __temp_def
del __temp_store, __temp_def



