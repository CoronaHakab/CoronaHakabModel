# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


import numpy as np


from contextlib import contextmanager



from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_parasymbolic')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_parasymbolic')
    _parasymbolic = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_parasymbolic', [dirname(__file__)])
        except ImportError:
            import _parasymbolic
            return _parasymbolic
        try:
            _mod = imp.load_module('_parasymbolic', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _parasymbolic = swig_import_helper()
    del swig_import_helper
else:
    import _parasymbolic
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class ParasymbolicMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParasymbolicMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParasymbolicMatrix, name)
    __repr__ = _swig_repr

    def __imul__(self, rhs: 'dtype') -> "void":
        """
        __imul__(self, rhs)

        Parameters
        ----------
        rhs: dtype

        """
        val = _parasymbolic.ParasymbolicMatrix___imul__(self, rhs)

        return self


        return val


    def __init__(self, size: 'size_t', component_count: 'size_t'):
        """
        __init__(self, size, component_count) -> ParasymbolicMatrix

        Parameters
        ----------
        size: size_t
        component_count: size_t

        """
        this = _parasymbolic.new_ParasymbolicMatrix(size, component_count)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get(self, *args) -> "dtype":
        """
        get(self, row, column) -> dtype

        Parameters
        ----------
        row: size_t
        column: size_t

        get(self, comp, row, column) -> dtype

        Parameters
        ----------
        comp: size_t
        row: size_t
        column: size_t

        """
        return _parasymbolic.ParasymbolicMatrix_get(self, *args)


    def total(self) -> "double":
        """
        total(self) -> double

        Parameters
        ----------
        self: ParasymbolicMatrix *

        """
        return _parasymbolic.ParasymbolicMatrix_total(self)


    def get_size(self) -> "size_t":
        """
        get_size(self) -> size_t

        Parameters
        ----------
        self: ParasymbolicMatrix *

        """
        return _parasymbolic.ParasymbolicMatrix_get_size(self)


    def _prob_any(self, A_v: 'dtype const *', A_non_zero_indices: 'size_t const *') -> "void":
        """
        _prob_any(self, A_v, A_non_zero_indices)

        Parameters
        ----------
        A_v: dtype const *
        A_non_zero_indices: size_t const *

        """
        return _parasymbolic.ParasymbolicMatrix__prob_any(self, A_v, A_non_zero_indices)


    def set_factors(self, A_factors: 'dtype const *') -> "void":
        """
        set_factors(self, A_factors)

        Parameters
        ----------
        A_factors: dtype const *

        """
        return _parasymbolic.ParasymbolicMatrix_set_factors(self, A_factors)


    def mul_sub_row(self, component: 'size_t', row: 'size_t', factor: 'dtype') -> "void":
        """
        mul_sub_row(self, component, row, factor)

        Parameters
        ----------
        component: size_t
        row: size_t
        factor: dtype

        """
        return _parasymbolic.ParasymbolicMatrix_mul_sub_row(self, component, row, factor)


    def mul_sub_col(self, component: 'size_t', col: 'size_t', factor: 'dtype') -> "void":
        """
        mul_sub_col(self, component, col, factor)

        Parameters
        ----------
        component: size_t
        col: size_t
        factor: dtype

        """
        return _parasymbolic.ParasymbolicMatrix_mul_sub_col(self, component, col, factor)


    def reset_mul_row(self, component: 'size_t', row: 'size_t') -> "void":
        """
        reset_mul_row(self, component, row)

        Parameters
        ----------
        component: size_t
        row: size_t

        """
        return _parasymbolic.ParasymbolicMatrix_reset_mul_row(self, component, row)


    def reset_mul_col(self, component: 'size_t', col: 'size_t') -> "void":
        """
        reset_mul_col(self, component, col)

        Parameters
        ----------
        component: size_t
        col: size_t

        """
        return _parasymbolic.ParasymbolicMatrix_reset_mul_col(self, component, col)


    def batch_set(self, component_num: 'size_t', row: 'size_t', A_columns: 'size_t const *', A_values: 'dtype const *') -> "void":
        """
        batch_set(self, component_num, row, A_columns, A_values)

        Parameters
        ----------
        component_num: size_t
        row: size_t
        A_columns: size_t const *
        A_values: dtype const *

        """
        return _parasymbolic.ParasymbolicMatrix_batch_set(self, component_num, row, A_columns, A_values)


    def set_calc_lock(self, value: 'bool') -> "void":
        """
        set_calc_lock(self, value)

        Parameters
        ----------
        value: bool

        """
        return _parasymbolic.ParasymbolicMatrix_set_calc_lock(self, value)

    __swig_destroy__ = _parasymbolic.delete_ParasymbolicMatrix
    __del__ = lambda self: None

    def non_zero_columns(self) -> "std::vector< std::vector< std::vector< size_t > > >":
        """
        non_zero_columns(self) -> std::vector< std::vector< std::vector< size_t > > >

        Parameters
        ----------
        self: ParasymbolicMatrix *

        """
        return _parasymbolic.ParasymbolicMatrix_non_zero_columns(self)


    if '''prob_any''' not in locals():

    	def prob_any(self, v): pass


    if '''__setitem__''' not in locals():

    	def __setitem__(self, key, v): pass


    if '''lock_rebuild''' not in locals():
    	@contextmanager
    	def lock_rebuild(self): pass

ParasymbolicMatrix_swigregister = _parasymbolic.ParasymbolicMatrix_swigregister
ParasymbolicMatrix_swigregister(ParasymbolicMatrix)


__temp_store = getattr(ParasymbolicMatrix,"""prob_any""",None)
def __temp_def(self, v):
	nz = np.flatnonzero(v).astype(np.uint64, copy=False)
	return self._prob_any(v, nz)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
ParasymbolicMatrix.prob_any = __temp_def
del __temp_store, __temp_def


__temp_store = getattr(ParasymbolicMatrix,"""__setitem__""",None)
def __temp_def(self, key, v):
	comp, row, indices = key
	indices = np.asanyarray(indices, dtype=np.uint64)
	v = np.asanyarray(v, dtype=np.float32)
	self.batch_set(comp, row, indices, v)
if isinstance(__temp_store, (classmethod, staticmethod, property)):
	__temp_def = type(__temp_store)(__temp_def)
__temp_def.prev = __temp_store
ParasymbolicMatrix.__setitem__ = __temp_def
del __temp_store, __temp_def


__temp_store = getattr(ParasymbolicMatrix,"""lock_rebuild""",None)
def __temp_def(self):
	self.set_calc_lock(True)
	yield self
	self.set_calc_lock(False)
__temp_def = contextmanager(__temp_def)
__temp_def.prev = __temp_store
ParasymbolicMatrix.lock_rebuild = __temp_def
del __temp_store, __temp_def

# This file is compatible with both classic and new-style classes.


